#Rules of coding: No math imports. Inbuilt code to use: +-/*, pow(integer values only). 
#No direct copying of outside code(creativity). No usage of AI (google summary doesn't count)
#Constants

def factorial(x,number=1):
    if x == 1 or x == 0:
        return 1
    else:
        return x * factorial(x-number,number=number)

e = 0
for x in range(0,100):
    e += 1/factorial(x)
pi = 0
for n in range(0,100):
    pi += (factorial(2*n,number=2))/factorial(2*n+1,number=2)*pow(1/2,n)
pi *= 2

#Basic
def abs(x):
    if x < 0:
        return -x
    else:
        return x
    
def root(x,rad=2):
    result = 0
    while pow(result,2) < x:
        result += 1
    for p in range(1,10):
        result = result - (pow(result,rad)-x)/(rad * pow(result,rad-1))
    return result

#Trig Functions

def sin(x,form="rad"):
    aConvert(x,form,"rad")
    while x < -1*pi or x> pi:
        x -= 2*pi
    result = 0
    for n in range(0,35):
        result += pow(-1,n)/factorial(2*n+1)*pow(x,2*n+1)
    return result

def cos(x,form="rad"):
    aConvert(x,form,"rad")
    while x < -1*pi or x> pi:
        x -= 2*pi
    result = 0
    for n in range(0,35):
        result += pow(-1,n)/factorial(2*n) * pow(x,2*n)
    return result

def tan(x,form="rad"):
    return sin(x,form)/cos(x,form)
    
def sec(x,form="rad"):
    return 1/cos(x,form)

def csc(x,form="rad"):
    return 1/sin(x,form)
    
def cot(x,form="rad"):
    return 1/tan(x,form)
    
#Hyperbolic Trig Functions

def tanh(x):
    return (exp(x)-exp(-x))/(exp(x)+exp(-x))

def cosh(x):
    return (exp(x)+exp(-x))/2

def sinh(x):
    return (exp(x)-exp(-x))/2
    
def sech(x):
    return 1/cosh(x)
    
def csch(x):
    return 1/sinh(x)
    
def coth(x):
    return 1/tanh(x)


#Inverse Trig Functions

def arctan(x):
    return (1j/2) * ln((1j+x)/(1j-x))

def arctanh(x):
    return -1j * arctan(1j * x)
    
def arccosh(x):
    return ln(x+(root(1+x)*root(x-1))) 

#Logarithms

def ln(a):
    if isinstance(a, complex):
        x, y = a.real, a.imag
        r = root(x*x + y*y)
        if x > 0:
            theta = arctan(y/x)
        elif x < 0 and y >= 0:
            theta = arctan(y/x) + pi
        elif x < 0 and y < 0:
            theta = arctan(y/x) - pi
        elif x == 0 and y > 0:
            theta = pi/2
        elif x == 0 and y < 0:
            theta = -pi/2
        else:
            raise ValueError("ln(0) is undefined")
        return ln(r) + 1j*theta
    else:
        result = -1000
        while pow(e, result) < a:
            result += 1
        for i in range(1,10):
            result = result - (pow(e, result)-a)/pow(e, result)
        return result


def log10(x):
    return ln(x)/ln(10)
    
def log(base,x):
    return ln(x)/ln(base)

def exp(x):
    return pow(e,x)
# Outputs    

def round(x,digits):
    return round(pow(10,digits)*x)/pow(10,digits)
    
def output(x):
    print(round(x,10))

#Conversions

def aConvert(inputValue,inputForm,outputForm):
    if inputForm == "deg":
        inputValue *= pi/180
    elif inputForm == "grad":
        inputValue *= pi/200
    elif inputForm != "rad":
        print("ConvertError")
    if outputForm == "deg":
        inputValue *= 180/pi
        return inputValue
    elif outputForm == "grad":
        inputValue *= 200/pi
        return inputValue
    elif outputForm != "rad":
        return inputValue

print(arctanh(10))
