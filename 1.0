#Basic
def factorial(x,number=1):
    if x == 1 or x == 0:
        return 1
    elif x<0:
        print("MathError: Factorial undefined for negative numbers.")
        return None
    else:
        return x * factorial(x-number,number=number)

def power(a,b):
    if not isinstance(a, complex) and not isinstance(b, complex):
        return pow(a,b)
    elif not isinstance(a, complex) and isinstance(b, complex):
        return pow(a,b.real) * exp(ln(a)*b.imag*1j)
    elif isinstance(a, complex) and not isinstance(b, complex):
        return pow(a,b)
    else:
        return power(a,b.real) * exp(ln(a)*b.imag*1j)

def my_abs(x):
    if x < 0:
        return -x
    else:
        return x
    
def root(x,rad=2):
    result = 0
    if x<0:
        if rad%2 ==0:
            while pow(result,2) < abs(x):
                result += 1
            for p in range(1,10):
                result = result - (pow(result,rad)-abs(x))/(rad * pow(result,rad-1))
            return result*1j
        else:
            while pow(result,2) < abs(x):
                result += 1
            for p in range(1,10):
                result = result - (pow(result,rad)-abs(x))/(rad * pow(result,rad-1))
            return -1*result
    else:
        while pow(result,2) < x:
            result += 1
        for p in range(1,10):
            result = result - (pow(result,rad)-x)/(rad * pow(result,rad-1))
        return result
    
#Constants

e = 0
for x in range(0,100):
    e += 1/factorial(x)
pi = 0
for n in range(0,100):
    pi += (factorial(2*n,number=2))/factorial(2*n+1,number=2)*pow(1/2,n)
pi *= 2

#Trig Functions

def arg(a):
    z=0
    if isinstance(a, complex):
        x, y = a.real, a.imag
        if x > 0:
            z = arctan(y/x)
        elif x < 0 and y >= 0:
            z = arctan(y/x) + pi
        elif x < 0 and y < 0:
            z = arctan(y/x) - pi
        elif x == 0 and y > 0:
            z = pi/2
        elif x == 0 and y < 0:
            z = -pi/2
        else:
            z = 0
    return z

    

def sin(x,form="rad"):
    x = aConvert(x,form,"rad")
    while x > pi:
        x -= 2*pi
    while x < -pi:
        x+= 2*pi
    result = 0
    for n in range(0,35):
        result += pow(-1,n)/factorial(2*n+1)*pow(x,2*n+1)
    return result

def cos(x,form="rad"):
    x = aConvert(x,form,"rad")
    while x > pi:
        x -= 2*pi
    while x < -pi:
        x+= 2*pi
    result = 0
    for n in range(0,35):
        result += pow(-1,n)/factorial(2*n) * pow(x,2*n)
    return result

def tan(x,form="rad"):
    return sin(x,form)/cos(x,form)
    
def sec(x,form="rad"):
    return 1/cos(x,form)

def csc(x,form="rad"):
    return 1/sin(x,form)
    
def cot(x,form="rad"):
    return 1/tan(x,form)
    
#Hyperbolic Trig Functions

def tanh(x):
    return (exp(x)-exp(-x))/(exp(x)+exp(-x))

def cosh(x):
    return (exp(x)+exp(-x))/2

def sinh(x):
    return (exp(x)-exp(-x))/2
    
def sech(x):
    return 1/cosh(x)
    
def csch(x):
    return 1/sinh(x)
    
def coth(x):
    return 1/tanh(x)


#Inverse Trig Functions

def arctan(x):
    if not isinstance(x, complex):
        if x > 0:
            result = 0
            if x > 0.5:
               return 1.5
            if x < 0.5:
               return 0.5
            result = 1.5
            for i in range(1,10):
                result = result - (sin(result)-x*cos(result))/(x*sin(result)+cos(result))
            return result
        elif x == 0:
            return 0
        if x < 0:
            return -arctan(-x)
    else:
        return (1j/2) * ln((1j+x)/(1j-x))

def arctanh(x):
    return -1j * arctan(1j * x)
    
def arccosh(x):
    return ln(x+(root(1+x)*root(x-1)))

def arcsin(x):
    if x == 1:
        return pi/2
    elif x == -1:
        return -pi/2
    else:
        return -1j * ln(1j*x+root(1-pow(x,2)))

#Logarithms

def ln(a):
    if isinstance(a, complex):
        x, y = a.real, a.imag
        r = root(x*x + y*y)
        return ln(r) + 1j*arg(a)
    elif a<0:
        result = -1000
        while pow(e, result) < abs(a):
            result += 1
        for i in range(1,10):
            result = result - (pow(e, result)-abs(a))/pow(e, result)
        return result+(1j*pi)
    elif a==0:
        print("MathError: ln(0) undefined")
        return None
    else:
        result = -1000
        while pow(e, result) < a:
            result += 1
        for i in range(1,10):
            result = result - (pow(e, result)-a)/pow(e, result)
        return result


def log10(x):
    return ln(x)/ln(10)
    
def log(base,x):
    return ln(x)/ln(base)

def exp(x):
    if not isinstance(x, complex):
        return pow(e,x)
    else:
        return (cos(x.imag) + sin(x.imag)*1j) * exp(x.real)
# Outputs    

def my_round(x,digits):
    return round(pow(10,digits)*x)/pow(10,digits)
    
def output(x):
    print(round(x,10))

#Conversions

def aConvert(inputValue,inputForm,outputForm):
    if inputForm == "deg":
        inputValue *= pi/180
    elif inputForm == "grad":
        inputValue *= pi/200
    elif inputForm == "rad":
        pass
    else:
        print("Unknown input form.")
    if outputForm == "deg":
        inputValue *= 180/pi
        return inputValue
    elif outputForm == "grad":
        inputValue *= 200/pi
        return inputValue
    elif outputForm == "rad":
        return inputValue
    else:
        print("Unknown output form.")

