#Basic
def factorial(x,number=1):
    if x == 1 or x == 0:
        return 1
    elif x<0:
        print("MathError: Factorial undefined for negative numbers.")
        return None
    else:
        return x * factorial(x-number,number=number)

def power(a,b):
    if not isinstance(a, complex) and not isinstance(b, complex):
        return pow(a,b)
    elif not isinstance(a, complex) and isinstance(b, complex):
        return pow(a,b.real) * exp(ln(a)*b.imag*1j)
    elif isinstance(a, complex) and not isinstance(b, complex):
        return pow(a,b)
    else:
        return power(a,b.real) * exp(ln(a)*b.imag*1j)

def my_abs(x):
    if x < 0:
        return -x
    else:
        return x
    
def root(x,rad=2):
    result = 0
    if x<0:
        if rad%2 ==0:
            while pow(result,2) < abs(x):
                result += 1
            for p in range(1,10):
                result = result - (pow(result,rad)-abs(x))/(rad * pow(result,rad-1))
            return result*1j
        else:
            while pow(result,2) < abs(x):
                result += 1
            for p in range(1,10):
                result = result - (pow(result,rad)-abs(x))/(rad * pow(result,rad-1))
            return -1*result
    else:
        while pow(result,2) < x:
            result += 1
        for p in range(1,10):
            result = result - (pow(result,rad)-x)/(rad * pow(result,rad-1))
        return result
    
#Constants

e = 0
for x in range(0,100):
    e += 1/factorial(x)
pi = 0
for n in range(0,100):
    pi += (factorial(2*n,number=2))/factorial(2*n+1,number=2)*pow(1/2,n)
pi *= 2

#Trig Functions

def arg(a):
    z=0
    if isinstance(a, complex):
        x, y = a.real, a.imag
        if x > 0:
            z = arctan(y/x)
        elif x < 0 and y >= 0:
            z = arctan(y/x) + pi
        elif x < 0 and y < 0:
            z = arctan(y/x) - pi
        elif x == 0 and y > 0:
            z = pi/2
        elif x == 0 and y < 0:
            z = -pi/2
        else:
            z = 0
    return z

    

def sin(x,form="rad"):
    x = aConvert(x,form,"rad")
    while x > pi:
        x -= 2*pi
    while x < -pi:
        x+= 2*pi
    result = 0
    for n in range(0,35):
        result += pow(-1,n)/factorial(2*n+1)*pow(x,2*n+1)
    return result

def cos(x,form="rad"):
    x = aConvert(x,form,"rad")
    while x > pi:
        x -= 2*pi
    while x < -pi:
        x+= 2*pi
    result = 0
    for n in range(0,35):
        result += pow(-1,n)/factorial(2*n) * pow(x,2*n)
    return result

def tan(x,form="rad"):
    return sin(x,form)/cos(x,form)
    
def sec(x,form="rad"):
    return 1/cos(x,form)

def csc(x,form="rad"):
    return 1/sin(x,form)
    
def cot(x,form="rad"):
    return 1/tan(x,form)
    
#Hyperbolic Trig Functions

def tanh(x):
    return (exp(x)-exp(-x))/(exp(x)+exp(-x))

def cosh(x):
    return (exp(x)+exp(-x))/2

def sinh(x):
    return (exp(x)-exp(-x))/2
    
def sech(x):
    return 1/cosh(x)
    
def csch(x):
    return 1/sinh(x)
    
def coth(x):
    return 1/tanh(x)


#Inverse Trig Functions

def arctan(x):
    if not isinstance(x, complex):
        if x > 0:
            result = 0
            if x > 0.5:
               return 1.5
            if x < 0.5:
               return 0.5
            result = 1.5
            for i in range(1,10):
                result = result - (sin(result)-x*cos(result))/(x*sin(result)+cos(result))
            return result
        elif x == 0:
            return 0
        if x < 0:
            return -arctan(-x)
    else:
        return (1j/2) * ln((1j+x)/(1j-x))

def arctanh(x):
    return -1j * arctan(1j * x)
    
def arccosh(x):
    return ln(x+(root(1+x)*root(x-1)))

def arcsin(x):
    if x == 1:
        return pi/2
    elif x == -1:
        return -pi/2
    else:
        return -1j * ln(1j*x+root(1-pow(x,2)))

#Logarithms

def ln(a):
    if isinstance(a, complex):
        x, y = a.real, a.imag
        r = root(x*x + y*y)
        return ln(r) + 1j*arg(a)
    elif a<0:
        result = -1000
        while pow(e, result) < abs(a):
            result += 1
        for i in range(1,10):
            result = result - (pow(e, result)-abs(a))/pow(e, result)
        return result+(1j*pi)
    elif a==0:
        print("MathError: ln(0) undefined")
        return None
    else:
        result = -1000
        while pow(e, result) < a:
            result += 1
        for i in range(1,10):
            result = result - (pow(e, result)-a)/pow(e, result)
        return result


def log10(x):
    return ln(x)/ln(10)
    
def log(base,x):
    return ln(x)/ln(base)

def exp(x):
    if not isinstance(x, complex):
        return pow(e,x)
    else:
        return (cos(x.imag) + sin(x.imag)*1j) * exp(x.real)
# Outputs    

def my_round(x,digits):
    return round(pow(10,digits)*x)/pow(10,digits)
    
def output(x):
    print(round(x,10))

#Conversions

def aConvert(inputValue,inputForm,outputForm):
    if inputForm == "deg":
        inputValue *= pi/180
    elif inputForm == "grad":
        inputValue *= pi/200
    elif inputForm == "rad":
        pass
    else:
        print("Unknown input form.")
    if outputForm == "deg":
        inputValue *= 180/pi
        return inputValue
    elif outputForm == "grad":
        inputValue *= 200/pi
        return inputValue
    elif outputForm == "rad":
        return inputValue
    else:
        print("Unknown output form.")

class Monomial:
    def __init__(self,coef,expon):
        if type(coef) != int or type(expon) != int:
            raise TypeError("Monomial Don't accept Non-Integers")
        if expon < 0:
            raise Exception("Exponent in Monomials has to be non-negative")
        self.coef = coef
        self.expon = expon

    def __eq__(self,other):
        if type(other) == Monomial:
            if self.coef == other.coef and self.expon == other.expon:
                return True
            else:
                return False
        

    def __invert__(self):
        return Monomial(-self.coef,self.expon)

    def __add__(self,other):
        if type(other) == Monomial:
            if other.expon == self.expon:
                return Monomial(self.coef+other.coef,self.expon)
            else:
                return Polynomial(self,other)
        elif type(other) == int:
            if self.expon == 0:
                return Monomial(self.coef+other,0)
            else:
                return Polynomial(self,Monomial(other,0))
        elif type(other) == Polynomial:
            list = other.monomials
            list.append(self)
            return Polynomial(list)
        raise TypeError(f"Monomials dont add with {type(other)}")
        
    def __sub__(self,other):
        if type(other) == Monomial:
            if other.expon == self.expon:
                return Monomial(self.coef-other.coef,self.expon)
            else:
                return Polynomial(self,-other)
        elif type(other) == int:
            if self.expon == 0:
                return Monomial(self.coef-other,0)
            else:
                return Polynomial(self,-Monomial(other,0))
        elif type(other) == Polynomial:
            return
        raise TypeError(f"Monomials dont subtract with {type(other)}")
        
    def __mult__(self,other):
        if type(other) == Monomial:
            return Monomial(self.coef*other.coef,self.expon+other.expon)
        elif type(other) == int:
            self.coef *= int
        elif type(other) == Polynomial:
            return
        raise TypeError(f"Monomials dont multiply with {type(other)}")

    def __str__(self):
        if self.coef == 0:
            return "0"
        elif self.expon == 0:
            return f"{self.coef}"
        elif self.coef == 1 and self.expon == 1:
            return f"x"
        elif self.coef == 1:
            return f"x^{self.expon}"
        elif self.expon == 1:
            return f"{self.coef}x"
        else:
            return f"{self.coef}x^{self.expon}"

    def __repr__(self):
        return f"{self.coef}x^{self.expon}"

    def expand(self):
        self.__class__ = Polynomial
        self.__init__(self)

class Polynomial:
    def append(self,monom):
        self.monomials.append(monom)

    def __init__(self, *monomials):
        self.monomials = list(monomials)
        if len(self.monomials) == 0:
            raise Exception("Polynomial Class can't be empty")

        if type(self.monomials[0]) == list:
            for i in self.monomials[0]:
                self.append(i)
            del self.monomials[0]

        for i in self.monomials:
            if type(i) != Monomial:
                print(type(i))
                raise TypeError(f"Polynomial doesn't accept non-monomials")
        # Need to Simplify

    def __contains__(self,term):
        if type(term) == Monomial:
            inside = False
            for i in self.monomials:
                if term == i:
                    inside = True
            return inside

    def __setitem__(self,exponent,coefficent):
        if exponent in self:
            self.monomials[exponent] = coefficent
        else: raise "Exponent not in Polynomial (setitem)"        

    def __getitem__(self,item):
        return self.monomials[item]

    def __len__(self):
        return len(self.monomials)
    
    def __iter__(self):
        for i in self.monomials:
            yield i
    
    def __str__(self):
        text = ""
        for i in self:
            text += f"{str(i)} + "
        text = text[:-3]
        return text

    def __add__(self,other):
        if type(other) == Monomial:
            return other + self
        elif type(other) == int:
            list = self.monomials
            list.append(Monomial(other,0))
            return Polynomial(list)

    def collapse(self):
        if len(self) == 1:
            self.__class__ = Monomial
            self.__init__(self.monomials[0].coef,self.monomials[0].expon)
        else:
            return Polynomial
#Calculus

def integral(func,a,b,prec=100000):
    sum = 0
    if a == b:
        return 0
    elif a > b:
        return -integral(func,b,a,prec=prec)
    else:
        for i in range(1,prec):
            sum += (func((b-a)/prec*i+a)*(b-a)/prec)
        return sum
